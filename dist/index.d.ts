// Generated by dts-bundle-generator v9.5.1

import { NextFunction, Request as Request$1, Response as Response$1 } from 'express';
import sql from 'mssql';
import { IResult } from 'mssql';

export declare class User {
	id: number;
	account: string;
	get profiles(): string[];
	constructor(id?: number, account?: string);
}
export interface ControllerParams {
	baseUrl?: string;
	allow?: Array<string>;
	deny?: Array<string>;
}
export declare function Controller(params?: ControllerParams | string): any;
export interface RepositoryParams {
	table?: string;
	view?: string;
	idField?: string;
	fulltextTable?: string;
	fulltextSearchField?: string;
	userBlame?: boolean;
}
export declare function Repository(params?: RepositoryParams): any;
export interface RouteParam {
	route: string;
	allow?: Array<string>;
	deny?: Array<string>;
}
export declare const GET: (params: RouteParam | string) => (target: any, propertyKey: string) => void;
export declare const POST: (params: RouteParam | string) => (target: any, propertyKey: string) => void;
export declare const DELETE: (params: RouteParam | string) => (target: any, propertyKey: string) => void;
export declare class HelloController {
	get(req: Request, res: Response<string | Error>): Promise<Response>;
	test(req: Request, res: Response<string | Error>): Promise<Response>;
	post(req: Request, res: Response<string | Error>): Promise<Response>;
}
export interface Mapper<T> {
	map(model: any): T;
	mapList(model: Array<any>): Array<T>;
}
export declare class BaseMapper<T> implements Mapper<T> {
	map(model: T): T;
	mapList(models: Array<T>): Array<T>;
}
export declare enum SortDirection {
	ASC = 0,
	DESC = 1
}
export interface Sort {
	column: string;
	direction: SortDirection;
}
export type DataTableResponse<T> = Response<DataTableResponseTyped<T>>;
export interface DataTableResponseTyped<T> {
	filtered_records: number;
	total_records: number;
	results: Array<T>;
}
export interface Filter {
	column: string;
	value: any;
}
export declare class BaseRepository<T> {
	protected mapper: BaseMapper<any>;
	protected get table(): any;
	protected get view(): any;
	protected get idField(): any;
	protected get fulltextTable(): any;
	protected get fulltextSearchField(): any;
	protected get userBlame(): any;
	protected get sql(): typeof sql;
	protected query(query: string): Promise<IResult<any>>;
	protected newRequest(): sql.Request;
	findOne(id: any): Promise<T | null | Error>;
	all(): Promise<Array<T> | Error>;
	datatable(page: number, pageSize: number, query: string, sort: Array<Sort>, filters: Array<Filter>, fulltextQueryWhere?: string): Promise<DataTableResponseTyped<T> | Error>;
	add(data: T): Promise<T | Error>;
	update(id: any, data: any): Promise<T | Error | null>;
	delete(id: any): Promise<boolean | Error>;
	search(page: number, pageSize: number, query: string, sort: Array<Sort>, filters: Array<Filter>, fulltextQueryWhere?: string): Promise<Array<T> | Error>;
	find(sort: Array<Sort>, filters: Array<Filter>): Promise<Array<T> | Error>;
}
export type DataTableRequest = Request<{}, {}, {}, DataTableRequestQuery>;
export interface DataTableRequestQuery {
	p: number;
	s: number;
	q: string;
	st: Array<Sort>;
	f: Array<Filter>;
}
export type SearchRequest = Request<{}, {}, {}, SearchRequestQuery>;
export interface SearchRequestQuery {
	p: number;
	s: number;
	q: string;
	st: Array<Sort>;
	f: Array<Filter>;
}
export type FindRequest = Request<{}, {}, {}, FindRequestQuery>;
export interface FindRequestQuery {
	st: Array<Sort>;
	f: Array<Filter>;
}
export declare class BaseController<TModel> {
	protected repository: BaseRepository<TModel> | null;
	constructor();
	protected response(model: any, res: Response, testNotFound?: boolean): Promise<Response>;
	index(req: Request, res: Response): Promise<Response>;
	datatables(req: DataTableRequest, res: Response): Promise<DataTableResponse<TModel>>;
	get(req: Request<{
		id: number;
	}>, res: Response): Promise<Response<TModel | null | Error>>;
	delete(req: Request<{
		id: number;
	}>, res: Response): Promise<Response<boolean | Error>>;
	add(req: Request, res: Response): Promise<Response<TModel | null | Error>>;
	update(req: Request, res: Response): Promise<Response<TModel | null | Error>>;
	search(req: SearchRequest, res: Response): Promise<Response>;
	find(req: FindRequest, res: Response): Promise<Response>;
}
export declare class AnalyticsController<T> extends BaseController<T> {
	private table;
	private userIdField;
	constructor(table: string, userIdField: string);
	add(req: Request, res: Response): Promise<Response>;
}
export declare function AuthenticateMiddleware(req: Request, res: Response, next: NextFunction): Promise<void>;
export declare function AccessLogMiddleWareBuilder(table: string, user_field: string): (req: Request, res: Response, next: NextFunction) => Promise<void>;
export declare class BaseError {
	number: number;
	message: any;
	error: boolean;
	constructor(number: number, message: any);
}
export declare class UserUtils {
	static getCurrentAccount(req?: Request): string;
	static getCurrentAccountId(req?: Request): number;
	static accountIntToString(account: number): string;
	static accountStringToInt(account: string): number;
}
export declare class Logger {
	private static _logging;
	private static _verbose;
	private static _queries;
	static set logging(value: boolean);
	static set verbose(value: boolean);
	static set queries(value: boolean);
	private static stringify;
	static log(...args: any[]): void;
	static logVerbose(...args: any[]): void;
	static info(...args: any[]): void;
	static infoVerbose(...args: any[]): void;
	static error(...args: any[]): void;
	static errorVerbose(...args: any[]): void;
	static logQuery(...args: any[]): void;
}
export declare class SqlUtils {
	static fulltextQuery(terms: string): string;
	static transactionWrapper(query: string, errorMessage?: string): string;
	static saveQuery(query: string, filename: string): void;
	static secureString: (value: string) => string;
}
export declare class RequestUtils {
	static extractDatatablesParams(queryObj: any): DataTableRequestQuery;
}
export interface ControllerRepositoryBuilderParams {
	route: string;
	repository: RepositoryParams;
	mapper?: BaseMapper<any>;
}
export declare class ControllerRepositoryUtils {
	static Build(params: ControllerRepositoryBuilderParams): {
		Repository: typeof BaseRepository<any>;
		Controller: typeof BaseController<any>;
	};
}
export declare class BaseService<T> {
	protected readonly serviceUrl = "/base-service";
	private static _instance;
	static get instance(): BaseService<any>;
	all(): Promise<Array<T>>;
	get(id: any): Promise<T>;
	find(): Promise<Array<T>>;
	datatables(): Promise<DataTableResponse<T>>;
	delete(id: any): Promise<boolean>;
	create(model: T): Promise<T>;
	update(id: any, model: T): Promise<T>;
	search(): Promise<Array<T>>;
}
export interface DatabaseConfig {
	user: string;
	password: string;
	server: string;
	database: string;
	requestTimeout?: number;
	connectionTimeout?: number;
}
export interface ServerConfig {
	name?: string;
	logging?: boolean;
	verbose?: boolean;
	logQueries?: boolean;
	database?: DatabaseConfig;
	port?: string | number;
	baseUrl?: string;
	license?: string;
	staticDirectory?: string;
	startupMessage?: boolean;
	onSigintEvent?: () => void;
}
export declare class Server {
	private static _instance;
	static get instance(): Server;
	private _config;
	get config(): ServerConfig;
	private _express;
	get name(): string | undefined;
	constructor(config?: ServerConfig);
	load(middlewares?: Array<any>, controllers?: Array<any>): Promise<Server>;
	private loadConfiguration;
	private loadLicenseString;
	private loadExpress;
	private loadDatabase;
	private bindSigintEvent;
	run(startingMessage?: string | null): Promise<void>;
	register: {
		controller: (controllerType: any) => void;
		middleware: (handler: any) => void;
	};
	private registerController;
	private registerMiddleware;
}

export {
	NextFunction,
	Request$1 as Request,
	Response$1 as Response,
};

export {};
